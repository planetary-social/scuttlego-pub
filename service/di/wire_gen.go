// Code generated by Wire. DO NOT EDIT.

//go:generate go run github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package di

import (
	"path/filepath"
	"testing"

	"github.com/boreq/errors"
	badger2 "github.com/dgraph-io/badger/v3"
	"github.com/planetary-social/scuttlego-pub/internal/fixtures"
	"github.com/planetary-social/scuttlego-pub/service"
	badger3 "github.com/planetary-social/scuttlego-pub/service/adapters/badger"
	"github.com/planetary-social/scuttlego-pub/service/adapters/mocks"
	"github.com/planetary-social/scuttlego-pub/service/app"
	"github.com/planetary-social/scuttlego-pub/service/app/commands"
	"github.com/planetary-social/scuttlego-pub/service/domain/messages/transport"
	"github.com/planetary-social/scuttlego/logging"
	migrations2 "github.com/planetary-social/scuttlego/migrations"
	"github.com/planetary-social/scuttlego/service/adapters"
	"github.com/planetary-social/scuttlego/service/adapters/badger"
	"github.com/planetary-social/scuttlego/service/adapters/badger/notx"
	ebt2 "github.com/planetary-social/scuttlego/service/adapters/ebt"
	"github.com/planetary-social/scuttlego/service/adapters/migrations"
	"github.com/planetary-social/scuttlego/service/adapters/pubsub"
	commands2 "github.com/planetary-social/scuttlego/service/app/commands"
	"github.com/planetary-social/scuttlego/service/app/queries"
	"github.com/planetary-social/scuttlego/service/domain"
	"github.com/planetary-social/scuttlego/service/domain/blobs"
	"github.com/planetary-social/scuttlego/service/domain/blobs/replication"
	"github.com/planetary-social/scuttlego/service/domain/feeds/content"
	transport2 "github.com/planetary-social/scuttlego/service/domain/feeds/content/transport"
	"github.com/planetary-social/scuttlego/service/domain/feeds/formats"
	"github.com/planetary-social/scuttlego/service/domain/identity"
	"github.com/planetary-social/scuttlego/service/domain/network"
	"github.com/planetary-social/scuttlego/service/domain/network/local"
	replication2 "github.com/planetary-social/scuttlego/service/domain/replication"
	"github.com/planetary-social/scuttlego/service/domain/replication/ebt"
	"github.com/planetary-social/scuttlego/service/domain/replication/gossip"
	"github.com/planetary-social/scuttlego/service/domain/rooms/tunnel"
	transport3 "github.com/planetary-social/scuttlego/service/domain/transport"
	"github.com/planetary-social/scuttlego/service/domain/transport/boxstream"
	"github.com/planetary-social/scuttlego/service/domain/transport/rpc"
	"github.com/planetary-social/scuttlego/service/domain/transport/rpc/mux"
	network2 "github.com/planetary-social/scuttlego/service/ports/network"
	pubsub2 "github.com/planetary-social/scuttlego/service/ports/pubsub"
	rpc2 "github.com/planetary-social/scuttlego/service/ports/rpc"
	"github.com/sirupsen/logrus"
)

// Injectors from wire.go:

func BuildService(private identity.Private, config service.Config) (service.Service, func(), error) {
	logrusLoggingSystem := newLoggingSystem()
	logger := newContextLogger(logrusLoggingSystem)
	db, cleanup, err := newBadger(logrusLoggingSystem, logger, config)
	if err != nil {
		return service.Service{}, nil, err
	}
	public := privateIdentityToPublicIdentity(private)
	adaptersFactory := badgerPubCommandsAdaptersFactory(config, public, logger)
	transactionProvider := newCommandsTransactionProvider(db, adaptersFactory)
	createInviteHandler := commands.NewCreateInviteHandler(transactionProvider)
	currentTimeProvider := adapters.NewCurrentTimeProvider()
	messageContentMappings := transport.Mappings()
	marshaler, err := transport2.NewMarshaler(messageContentMappings, logger)
	if err != nil {
		cleanup()
		return service.Service{}, nil, err
	}
	redeemInviteHandler := commands.NewRedeemInviteHandler(transactionProvider, currentTimeProvider, marshaler, private)
	appCommands := app.Commands{
		CreateInvite: createInviteHandler,
		RedeemInvite: redeemInviteHandler,
	}
	appQueries := app.Queries{}
	application := app.Application{
		Commands: appCommands,
		Queries:  appQueries,
	}
	badgerStorage := migrations.NewBadgerStorage(db)
	runner := migrations2.NewRunner(badgerStorage, logger)
	v := newMigrationsList()
	migrationsMigrations, err := migrations2.NewMigrations(v)
	if err != nil {
		cleanup()
		return service.Service{}, nil, err
	}
	runMigrationsHandler := commands2.NewRunMigrationsHandler(runner, migrationsMigrations)
	networkKey := extractNetworkKeyFromConfig(config)
	handshaker, err := boxstream.NewHandshaker(private, networkKey, currentTimeProvider)
	if err != nil {
		cleanup()
		return service.Service{}, nil, err
	}
	requestPubSub := pubsub.NewRequestPubSub()
	connectionIdGenerator := rpc.NewConnectionIdGenerator()
	newPeerPubSub := pubsub.NewNewPeerPubSub()
	peerInitializer := transport3.NewPeerInitializer(handshaker, requestPubSub, connectionIdGenerator, newPeerPubSub, logger)
	listener, err := newListener(peerInitializer, config, logger)
	if err != nil {
		cleanup()
		return service.Service{}, nil, err
	}
	discoverer, err := local.NewDiscoverer(public, logger)
	if err != nil {
		cleanup()
		return service.Service{}, nil, err
	}
	peerManagerConfig := newPeerManagerConfig()
	dialer, err := network.NewDialer(peerInitializer, logger)
	if err != nil {
		cleanup()
		return service.Service{}, nil, err
	}
	tunnelDialer := tunnel.NewDialer(peerInitializer)
	peerManager := domain.NewPeerManager(peerManagerConfig, dialer, tunnelDialer, logger)
	processNewLocalDiscoveryHandler := commands2.NewProcessNewLocalDiscoveryHandler(peerManager)
	networkDiscoverer := network2.NewDiscoverer(discoverer, processNewLocalDiscoveryHandler, logger)
	establishNewConnectionsHandler := commands2.NewEstablishNewConnectionsHandler(peerManager)
	connectionEstablisher := network2.NewConnectionEstablisher(establishNewConnectionsHandler, logger)
	filesystemStorage, err := newFilesystemStorage(logger, config)
	if err != nil {
		cleanup()
		return service.Service{}, nil, err
	}
	getBlobHandler, err := queries.NewGetBlobHandler(filesystemStorage)
	if err != nil {
		cleanup()
		return service.Service{}, nil, err
	}
	handlerBlobsGet := rpc2.NewHandlerBlobsGet(getBlobHandler)
	txAdaptersFactory := noTxTxAdaptersFactory(public, config, logger)
	txAdaptersFactoryTransactionProvider := notx.NewTxAdaptersFactoryTransactionProvider(db, txAdaptersFactory)
	noTxBlobWantListRepository := notx.NewNoTxBlobWantListRepository(txAdaptersFactoryTransactionProvider, logger)
	noTxBlobsRepository := notx.NewNoTxBlobsRepository(txAdaptersFactoryTransactionProvider)
	storageBlobsThatShouldBePushedProvider, err := replication.NewStorageBlobsThatShouldBePushedProvider(noTxBlobsRepository, public, currentTimeProvider)
	if err != nil {
		cleanup()
		return service.Service{}, nil, err
	}
	blobsGetDownloader := replication.NewBlobsGetDownloader(filesystemStorage, logger)
	blobDownloadedPubSub := pubsub.NewBlobDownloadedPubSub()
	hasHandler := replication.NewHasHandler(filesystemStorage, noTxBlobWantListRepository, blobsGetDownloader, blobDownloadedPubSub, logger)
	diManagedWantsProcessFactory := newManagedWantsProcessFactory(noTxBlobWantListRepository, storageBlobsThatShouldBePushedProvider, filesystemStorage, hasHandler, logger)
	manager := replication.NewManager(diManagedWantsProcessFactory, logger)
	createWantsHandler := commands2.NewCreateWantsHandler(manager)
	handlerBlobsCreateWants := rpc2.NewHandlerBlobsCreateWants(createWantsHandler)
	sessionTracker := ebt.NewSessionTracker()
	scanner := blobs.NewScanner()
	parser := content.NewParser(marshaler, scanner)
	messageHMAC := extractMessageHMACFromConfig(config)
	scuttlebutt := formats.NewScuttlebutt(parser, messageHMAC)
	v2 := newFormats(scuttlebutt)
	rawMessageIdentifier := formats.NewRawMessageIdentifier(v2)
	commandsAdaptersFactory := badgerScuttlegoCommandsAdaptersFactory(config, public, logger)
	commandsTransactionProvider := badger.NewCommandsTransactionProvider(db, commandsAdaptersFactory)
	queriesAdaptersFactory := badgerScuttlegoQueriesAdaptersFactory(config, public, logger)
	queriesTransactionProvider := badger.NewQueriesTransactionProvider(db, queriesAdaptersFactory)
	wantedFeedsProvider := queries.NewWantedFeedsProvider(queriesTransactionProvider)
	wantedFeedsCache := replication2.NewWantedFeedsCache(wantedFeedsProvider)
	messageBuffer := commands2.NewMessageBuffer(commandsTransactionProvider, rawMessageIdentifier, wantedFeedsCache, logger)
	rawMessageHandler := commands2.NewRawMessageHandler(rawMessageIdentifier, messageBuffer, logger)
	messagePubSub := pubsub.NewMessagePubSub()
	createHistoryStreamHandler := queries.NewCreateHistoryStreamHandler(queriesTransactionProvider, messagePubSub, logger)
	createHistoryStreamHandlerAdapter := ebt2.NewCreateHistoryStreamHandlerAdapter(createHistoryStreamHandler)
	sessionRunner := ebt.NewSessionRunner(logger, rawMessageHandler, wantedFeedsCache, createHistoryStreamHandlerAdapter)
	gossipManager := gossip.NewManager(logger, wantedFeedsCache)
	gossipReplicator, err := gossip.NewGossipReplicator(gossipManager, rawMessageHandler, logger)
	if err != nil {
		cleanup()
		return service.Service{}, nil, err
	}
	replicator := ebt.NewReplicator(sessionTracker, sessionRunner, gossipReplicator, logger)
	handleIncomingEbtReplicateHandler := commands2.NewHandleIncomingEbtReplicateHandler(replicator)
	handlerEbtReplicate := rpc2.NewHandlerEbtReplicate(handleIncomingEbtReplicateHandler)
	acceptTunnelConnectHandler := commands2.NewAcceptTunnelConnectHandler(public, peerInitializer)
	handlerTunnelConnect := rpc2.NewHandlerTunnelConnect(acceptTunnelConnectHandler)
	v3 := rpc2.NewMuxHandlers(handlerBlobsGet, handlerBlobsCreateWants, handlerEbtReplicate, handlerTunnelConnect)
	handlerCreateHistoryStream := rpc2.NewHandlerCreateHistoryStream(createHistoryStreamHandler, logger)
	v4 := rpc2.NewMuxClosingHandlers(handlerCreateHistoryStream)
	muxMux, err := mux.NewMux(logger, v3, v4)
	if err != nil {
		cleanup()
		return service.Service{}, nil, err
	}
	requestSubscriber := pubsub2.NewRequestSubscriber(requestPubSub, muxMux)
	roomAttendantEventPubSub := pubsub.NewRoomAttendantEventPubSub()
	processRoomAttendantEventHandler := commands2.NewProcessRoomAttendantEventHandler(peerManager)
	roomAttendantEventSubscriber := pubsub2.NewRoomAttendantEventSubscriber(roomAttendantEventPubSub, processRoomAttendantEventHandler, logger)
	advertiser, err := newAdvertiser(public, config)
	if err != nil {
		cleanup()
		return service.Service{}, nil, err
	}
	garbageCollector := badger.NewGarbageCollector(db, logger)
	serviceService := service.NewService(application, runMigrationsHandler, listener, networkDiscoverer, connectionEstablisher, requestSubscriber, roomAttendantEventSubscriber, advertiser, messageBuffer, createHistoryStreamHandler, garbageCollector)
	return serviceService, func() {
		cleanup()
	}, nil
}

func BuildTestApplication(tb testing.TB) (TestApplication, error) {
	socialGraphRepositoryMock := mocks.NewSocialGraphRepositoryMock()
	inviteRespositoryMock := mocks.NewInviteRespositoryMock()
	feedFormatMock := mocks.NewFeedFormatMock()
	feedRepositoryMock := mocks.NewFeedRepositoryMock(feedFormatMock)
	commandsAdapters := commands.Adapters{
		SocialGraph: socialGraphRepositoryMock,
		Invite:      inviteRespositoryMock,
		Feed:        feedRepositoryMock,
	}
	mockCommandsTransactionProvider := mocks.NewMockCommandsTransactionProvider(commandsAdapters)
	createInviteHandler := commands.NewCreateInviteHandler(mockCommandsTransactionProvider)
	currentTimeProviderMock := mocks.NewCurrentTimeProviderMock()
	marshalerMock := mocks.NewMarshalerMock()
	private := fixtures.SomePrivateIdentity()
	redeemInviteHandler := commands.NewRedeemInviteHandler(mockCommandsTransactionProvider, currentTimeProviderMock, marshalerMock, private)
	appCommands := app.Commands{
		CreateInvite: createInviteHandler,
		RedeemInvite: redeemInviteHandler,
	}
	testApplication := TestApplication{
		Commands:              appCommands,
		SocialGraphRepository: socialGraphRepositoryMock,
		InviteRepository:      inviteRespositoryMock,
		FeedRepository:        feedRepositoryMock,
		Marshaler:             marshalerMock,
		FeedFormat:            feedFormatMock,
		LocalIdentity:         private,
		CurrentTimeProvider:   currentTimeProviderMock,
	}
	return testApplication, nil
}

func BuildBadgerTestAdapters(tb testing.TB) (BadgerTestAdapters, error) {
	db := fixtures.Badger(tb)
	adaptersFactory := badgerTestAdaptersFactory()
	transactionProvider := newTestTransactionProvider(db, adaptersFactory)
	badgerTestAdapters := BadgerTestAdapters{
		TransactionProvider: transactionProvider,
	}
	return badgerTestAdapters, nil
}

func buildBadgerNoTxTxAdapters(txn *badger2.Txn, public identity.Public, config service.Config, logger logging.Logger) (notx.TxAdapters, error) {
	banListHasher := adapters.NewBanListHasher()
	banListRepository := badger.NewBanListRepository(txn, banListHasher)
	blobRepository := badger.NewBlobRepository(txn)
	currentTimeProvider := adapters.NewCurrentTimeProvider()
	blobWantListRepository := badger.NewBlobWantListRepository(txn, currentTimeProvider)
	feedWantListRepository := badger.NewFeedWantListRepository(txn, currentTimeProvider)
	messageContentMappings := transport.Mappings()
	marshaler, err := transport2.NewMarshaler(messageContentMappings, logger)
	if err != nil {
		return notx.TxAdapters{}, err
	}
	scanner := blobs.NewScanner()
	parser := content.NewParser(marshaler, scanner)
	messageHMAC := extractMessageHMACFromConfig(config)
	scuttlebutt := formats.NewScuttlebutt(parser, messageHMAC)
	v := newFormats(scuttlebutt)
	rawMessageIdentifier := formats.NewRawMessageIdentifier(v)
	messageRepository := badger.NewMessageRepository(txn, rawMessageIdentifier)
	receiveLogRepository := badger.NewReceiveLogRepository(txn, messageRepository)
	hops := extractHopsFromConfig(config)
	socialGraphRepository := badger.NewSocialGraphRepository(txn, public, hops, banListRepository, banListHasher)
	pubRepository := badger.NewPubRepository(txn)
	feedRepository := badger.NewFeedRepository(txn, socialGraphRepository, receiveLogRepository, messageRepository, pubRepository, blobRepository, banListRepository, scuttlebutt)
	txAdapters := notx.TxAdapters{
		BanListRepository:      banListRepository,
		BlobRepository:         blobRepository,
		BlobWantListRepository: blobWantListRepository,
		FeedWantListRepository: feedWantListRepository,
		MessageRepository:      messageRepository,
		ReceiveLogRepository:   receiveLogRepository,
		SocialGraphRepository:  socialGraphRepository,
		PubRepository:          pubRepository,
		FeedRepository:         feedRepository,
	}
	return txAdapters, nil
}

func buildBadgerScuttlegoCommandsAdapters(txn *badger2.Txn, public identity.Public, config service.Config, logger logging.Logger) (commands2.Adapters, error) {
	hops := extractHopsFromConfig(config)
	banListHasher := adapters.NewBanListHasher()
	banListRepository := badger.NewBanListRepository(txn, banListHasher)
	socialGraphRepository := badger.NewSocialGraphRepository(txn, public, hops, banListRepository, banListHasher)
	messageContentMappings := transport.Mappings()
	marshaler, err := transport2.NewMarshaler(messageContentMappings, logger)
	if err != nil {
		return commands2.Adapters{}, err
	}
	scanner := blobs.NewScanner()
	parser := content.NewParser(marshaler, scanner)
	messageHMAC := extractMessageHMACFromConfig(config)
	scuttlebutt := formats.NewScuttlebutt(parser, messageHMAC)
	v := newFormats(scuttlebutt)
	rawMessageIdentifier := formats.NewRawMessageIdentifier(v)
	messageRepository := badger.NewMessageRepository(txn, rawMessageIdentifier)
	receiveLogRepository := badger.NewReceiveLogRepository(txn, messageRepository)
	pubRepository := badger.NewPubRepository(txn)
	blobRepository := badger.NewBlobRepository(txn)
	feedRepository := badger.NewFeedRepository(txn, socialGraphRepository, receiveLogRepository, messageRepository, pubRepository, blobRepository, banListRepository, scuttlebutt)
	currentTimeProvider := adapters.NewCurrentTimeProvider()
	blobWantListRepository := badger.NewBlobWantListRepository(txn, currentTimeProvider)
	feedWantListRepository := badger.NewFeedWantListRepository(txn, currentTimeProvider)
	commandsAdapters := commands2.Adapters{
		Feed:         feedRepository,
		ReceiveLog:   receiveLogRepository,
		SocialGraph:  socialGraphRepository,
		BlobWantList: blobWantListRepository,
		FeedWantList: feedWantListRepository,
		BanList:      banListRepository,
	}
	return commandsAdapters, nil
}

func buildBadgerScuttlegoQueriesAdapters(txn *badger2.Txn, public identity.Public, config service.Config, logger logging.Logger) (queries.Adapters, error) {
	hops := extractHopsFromConfig(config)
	banListHasher := adapters.NewBanListHasher()
	banListRepository := badger.NewBanListRepository(txn, banListHasher)
	socialGraphRepository := badger.NewSocialGraphRepository(txn, public, hops, banListRepository, banListHasher)
	messageContentMappings := transport.Mappings()
	marshaler, err := transport2.NewMarshaler(messageContentMappings, logger)
	if err != nil {
		return queries.Adapters{}, err
	}
	scanner := blobs.NewScanner()
	parser := content.NewParser(marshaler, scanner)
	messageHMAC := extractMessageHMACFromConfig(config)
	scuttlebutt := formats.NewScuttlebutt(parser, messageHMAC)
	v := newFormats(scuttlebutt)
	rawMessageIdentifier := formats.NewRawMessageIdentifier(v)
	messageRepository := badger.NewMessageRepository(txn, rawMessageIdentifier)
	receiveLogRepository := badger.NewReceiveLogRepository(txn, messageRepository)
	pubRepository := badger.NewPubRepository(txn)
	blobRepository := badger.NewBlobRepository(txn)
	feedRepository := badger.NewFeedRepository(txn, socialGraphRepository, receiveLogRepository, messageRepository, pubRepository, blobRepository, banListRepository, scuttlebutt)
	currentTimeProvider := adapters.NewCurrentTimeProvider()
	feedWantListRepository := badger.NewFeedWantListRepository(txn, currentTimeProvider)
	queriesAdapters := queries.Adapters{
		Feed:         feedRepository,
		ReceiveLog:   receiveLogRepository,
		Message:      messageRepository,
		SocialGraph:  socialGraphRepository,
		FeedWantList: feedWantListRepository,
		BanList:      banListRepository,
	}
	return queriesAdapters, nil
}

func buildBadgerPubCommandsAdapters(txn *badger2.Txn, public identity.Public, config service.Config, logger logging.Logger) (commands.Adapters, error) {
	hops := extractHopsFromConfig(config)
	banListHasher := adapters.NewBanListHasher()
	banListRepository := badger.NewBanListRepository(txn, banListHasher)
	socialGraphRepository := badger.NewSocialGraphRepository(txn, public, hops, banListRepository, banListHasher)
	inviteRepository := badger3.NewInviteRepository(txn)
	messageContentMappings := transport.Mappings()
	marshaler, err := transport2.NewMarshaler(messageContentMappings, logger)
	if err != nil {
		return commands.Adapters{}, err
	}
	scanner := blobs.NewScanner()
	parser := content.NewParser(marshaler, scanner)
	messageHMAC := extractMessageHMACFromConfig(config)
	scuttlebutt := formats.NewScuttlebutt(parser, messageHMAC)
	v := newFormats(scuttlebutt)
	rawMessageIdentifier := formats.NewRawMessageIdentifier(v)
	messageRepository := badger.NewMessageRepository(txn, rawMessageIdentifier)
	receiveLogRepository := badger.NewReceiveLogRepository(txn, messageRepository)
	pubRepository := badger.NewPubRepository(txn)
	blobRepository := badger.NewBlobRepository(txn)
	feedRepository := badger.NewFeedRepository(txn, socialGraphRepository, receiveLogRepository, messageRepository, pubRepository, blobRepository, banListRepository, scuttlebutt)
	commandsAdapters := commands.Adapters{
		SocialGraph: socialGraphRepository,
		Invite:      inviteRepository,
		Feed:        feedRepository,
	}
	return commandsAdapters, nil
}

func buildBadgerTestAdapters(txn *badger2.Txn) (TestAdapters, error) {
	inviteRepository := badger3.NewInviteRepository(txn)
	testAdapters := TestAdapters{
		InviteRepository: inviteRepository,
	}
	return testAdapters, nil
}

// wire.go:

type TestApplication struct {
	Commands app.Commands

	SocialGraphRepository *mocks.SocialGraphRepositoryMock
	InviteRepository      *mocks.InviteRespositoryMock
	FeedRepository        *mocks.FeedRepositoryMock
	Marshaler             *mocks.MarshalerMock
	FeedFormat            *mocks.FeedFormatMock
	LocalIdentity         identity.Private
	CurrentTimeProvider   *mocks.CurrentTimeProviderMock
}

type BadgerTestAdapters struct {
	TransactionProvider *TestTransactionProvider
}

func newAdvertiser(l identity.Public, config service.Config) (*local.Advertiser, error) {
	return local.NewAdvertiser(l, config.ListenAddress)
}

func newBadger(system logging.LoggingSystem, logger logging.Logger, config service.Config) (*badger2.DB, func(), error) {
	badgerDirectory := filepath.Join(config.DataDirectory, "badger")

	options := badger2.DefaultOptions(badgerDirectory)
	options.Logger = badger.NewLogger(system, badger.LoggerLevelWarning)
	options.SyncWrites = true

	db, err := badger2.Open(options)
	if err != nil {
		return nil, nil, errors.Wrap(err, "failed to open the database")
	}

	return db, func() {
		if err := db.Close(); err != nil {
			logger.Error().WithError(err).Message("error closing the database")
		}
	}, nil

}

func privateIdentityToPublicIdentity(p identity.Private) identity.Public {
	return p.Public()
}

func newContextLogger(loggingSystem logging.LoggingSystem) logging.Logger {
	return logging.NewContextLogger(loggingSystem, "scuttlego")
}

func newLoggingSystem() logging.LogrusLoggingSystem {
	logger := logrus.New()

	return logging.NewLogrusLoggingSystem(logger)
}

func newPeerManagerConfig() domain.PeerManagerConfig {
	return domain.PeerManagerConfig{
		PreferredPubs: nil,
	}
}
